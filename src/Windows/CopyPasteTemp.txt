//When writing software I often find myself heading down a direction to solve one problem when I realize that
//there is a better solution to try, or I see another problem that I must resolve first.  Since I am a one
//person company, I often use the readme.md file as a temporary scratchpad where code can be placed aside.
//With a public or shared repository like this one, the readme is not the best place for it.  I will use this
//file as that scratchpad, checking it into the repository because it will sometimes contain content that I
//want to keep persisted and associated with this project.  That way when I get pulled off to go work on other
//projects, I will know exactly where I left off.
        

//In WPF this lets me have a completely transparent Window that is not hit testable and can have non-transparent 
//content.  In WinUI, I have not been able to get it to work yet.  I know that WinUI does not support the acrylic
//features but from what others stated, there are ways to have a transparent Window.  When I am done with the
//SizeToContent feature, I might take another stab at it.  I moved over to SizeToContent, got it working perfectly
//for downsizing but I am having a rough time calculating the required size of all controls such as StackPanels
//and Grids. 
using System;
using System.Runtime.InteropServices;
using PInvoke;
namespace WinUI.Native
{
    public static class Transparency
    {
        private const int GWL_EXSTYLE = -20;

        [DllImport("user32.dll", SetLastError = true)]
        private static extern int GetWindowLong(IntPtr hwnd, int index);

        [DllImport("user32.dll", SetLastError = true)]
        private static extern int SetWindowLong(IntPtr hwnd, int index, int newStyle);

        public static void MakeTransparent(IntPtr hwnd)
        {
            var extendedStyle = (User32.WindowStylesEx)GetWindowLong(hwnd, GWL_EXSTYLE);
            SetWindowLong(hwnd, GWL_EXSTYLE, (int)(extendedStyle| User32.WindowStylesEx.WS_EX_TRANSPARENT | User32.WindowStylesEx.WS_EX_LAYERED));
        }

        public static void RemoveTransparency(IntPtr hwnd)
        {
            var extendedStyle = (User32.WindowStylesEx)GetWindowLong(hwnd, GWL_EXSTYLE);
            SetWindowLong(hwnd, GWL_EXSTYLE, (int)(extendedStyle & ~User32.WindowStylesEx.WS_EX_TRANSPARENT));
        }

    }
}
